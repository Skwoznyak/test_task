<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Управление задачами{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .notification-badge {
            position: relative;
        }
        .notification-badge::after {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 10px;
            height: 10px;
            background-color: #dc3545;
            border-radius: 50%;
            display: none;
        }
        .notification-badge.has-notifications::after {
            display: block;
        }
        .task-card {
            transition: transform 0.2s;
        }
        .task-card:hover {
            transform: translateY(-2px);
        }
        .priority-high {
            border-left: 4px solid #dc3545;
        }
        .priority-medium {
            border-left: 4px solid #ffc107;
        }
        .priority-low {
            border-left: 4px solid #28a745;
        }
        .status-pending {
            background-color: #f8f9fa;
        }
        .status-in-progress {
            background-color: #e3f2fd;
        }
        .status-completed {
            background-color: #e8f5e8;
        }
        .status-cancelled {
            background-color: #ffebee;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="{% url 'index' %}">
                <i class="fas fa-tasks"></i> Task Manager
            </a>
            
            {% if user.is_authenticated %}
            <div class="navbar-nav ms-auto">
                <div class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle notification-badge" href="#" id="notificationDropdown" role="button" data-bs-toggle="dropdown">
                        <i class="fas fa-bell"></i>
                        <span id="notification-count" class="badge bg-danger">0</span>
                    </a>
                    <ul class="dropdown-menu dropdown-menu-end" id="notification-list">
                        <li><h6 class="dropdown-header">Уведомления</h6></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" href="#" id="no-notifications">Нет уведомлений</a></li>
                    </ul>
                </div>
                <div class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="userDropdown" role="button" data-bs-toggle="dropdown">
                        <i class="fas fa-user"></i> {{ user.username }}
                    </a>
                    <ul class="dropdown-menu dropdown-menu-end">
                        <li><a class="dropdown-item" href="#" onclick="showProfileModal()">
                            <i class="fas fa-user-cog"></i> Профиль
                        </a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" href="{% url 'logout' %}">
                            <i class="fas fa-sign-out-alt"></i> Выход
                        </a></li>
                    </ul>
                </div>
            </div>
            {% else %}
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="{% url 'login' %}">Вход</a>
                <a class="nav-link" href="{% url 'register' %}">Регистрация</a>
            </div>
            {% endif %}
        </div>
    </nav>

    <main class="container mt-4">
        {% block content %}{% endblock %}
    </main>

    <!-- Модальное окно профиля -->
    <div class="modal fade" id="profileModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Настройки профиля</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="profile-form">
                        <div class="mb-3">
                            <label for="telegram-chat-id" class="form-label">Telegram Chat ID</label>
                            <input type="text" class="form-control" id="telegram-chat-id" readonly>
                            <div class="form-text">Используйте этот ID для привязки Telegram-бота</div>
                        </div>
                        <div class="mb-3">
                            <label for="telegram-username" class="form-label">Telegram Username</label>
                            <input type="text" class="form-control" id="telegram-username" placeholder="@username">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    <button type="button" class="btn btn-primary" onclick="saveProfile()">Сохранить</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // WebSocket соединение
        let socket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        function connectWebSocket() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                return;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/tasks/`;
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(event) {
                console.log('WebSocket connected');
                reconnectAttempts = 0;
                // Отправляем ping для проверки соединения
                socket.send(JSON.stringify({type: 'ping'}));
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            socket.onclose = function(event) {
                console.log('WebSocket disconnected');
                if (reconnectAttempts < maxReconnectAttempts) {
                    setTimeout(() => {
                        reconnectAttempts++;
                        connectWebSocket();
                    }, 2000 * reconnectAttempts);
                }
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'notification':
                    showNotification(data.message);
                    updateNotificationCount();
                    break;
                case 'tasks_data':
                    updateTasksList(data.tasks);
                    break;
                case 'pong':
                    // Соединение активно
                    break;
            }
        }

        function showNotification(message) {
            // Показываем уведомление в браузере
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification('Новое уведомление', {
                        body: message,
                        icon: '/static/favicon.ico'
                    });
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            new Notification('Новое уведомление', {
                                body: message,
                                icon: '/static/favicon.ico'
                            });
                        }
                    });
                }
            }
            
            // Показываем toast уведомление
            showToast(message, 'info');
        }

        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container') || createToastContainer();
            
            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-white bg-${type} border-0`;
            toast.setAttribute('role', 'alert');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">${message}</div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            `;
            
            toastContainer.appendChild(toast);
            
            const bsToast = new bootstrap.Toast(toast);
            bsToast.show();
            
            // Удаляем toast после скрытия
            toast.addEventListener('hidden.bs.toast', () => {
                toast.remove();
            });
        }

        function createToastContainer() {
            const container = document.createElement('div');
            container.id = 'toast-container';
            container.className = 'toast-container position-fixed top-0 end-0 p-3';
            container.style.zIndex = '9999';
            document.body.appendChild(container);
            return container;
        }

        function updateNotificationCount() {
            fetch('/api/notifications/unread_count/')
                .then(response => response.json())
                .then(data => {
                    const count = data.unread_count;
                    const badge = document.getElementById('notification-count');
                    const notificationBadge = document.querySelector('.notification-badge');
                    
                    badge.textContent = count;
                    
                    if (count > 0) {
                        notificationBadge.classList.add('has-notifications');
                    } else {
                        notificationBadge.classList.remove('has-notifications');
                    }
                });
        }

        function loadNotifications() {
            fetch('/api/notifications/')
                .then(response => response.json())
                .then(data => {
                    const notificationList = document.getElementById('notification-list');
                    notificationList.innerHTML = '<li><h6 class="dropdown-header">Уведомления</h6></li><li><hr class="dropdown-divider"></li>';
                    
                    if (data.length === 0) {
                        notificationList.innerHTML += '<li><a class="dropdown-item" href="#" id="no-notifications">Нет уведомлений</a></li>';
                    } else {
                        data.slice(0, 5).forEach(notification => {
                            const item = document.createElement('li');
                            item.innerHTML = `
                                <a class="dropdown-item ${notification.is_read ? '' : 'fw-bold'}" href="#" onclick="markNotificationRead(${notification.id})">
                                    <div class="d-flex w-100 justify-content-between">
                                        <h6 class="mb-1">${notification.title}</h6>
                                        <small>${new Date(notification.created_at).toLocaleString()}</small>
                                    </div>
                                    <p class="mb-1">${notification.message}</p>
                                </a>
                            `;
                            notificationList.appendChild(item);
                        });
                    }
                });
        }

        function markNotificationRead(notificationId) {
            fetch(`/api/notifications/${notificationId}/mark_read/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            }).then(() => {
                updateNotificationCount();
                loadNotifications();
            });
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        function showProfileModal() {
            fetch('/api/profiles/')
                .then(response => response.json())
                .then(data => {
                    if (data.length > 0) {
                        const profile = data[0];
                        document.getElementById('telegram-chat-id').value = profile.telegram_chat_id || 'Не привязан';
                        document.getElementById('telegram-username').value = profile.telegram_username || '';
                    }
                });
            
            const modal = new bootstrap.Modal(document.getElementById('profileModal'));
            modal.show();
        }

        function saveProfile() {
            const telegramUsername = document.getElementById('telegram-username').value;
            
            fetch('/api/profiles/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    telegram_username: telegramUsername
                })
            }).then(response => {
                if (response.ok) {
                    showToast('Профиль обновлен', 'success');
                    bootstrap.Modal.getInstance(document.getElementById('profileModal')).hide();
                } else {
                    showToast('Ошибка при обновлении профиля', 'danger');
                }
            });
        }

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            if ({{ user.is_authenticated|yesno:"true,false" }}) {
                connectWebSocket();
                updateNotificationCount();
                loadNotifications();
                
                // Обновляем уведомления каждые 30 секунд
                setInterval(loadNotifications, 30000);
            }
        });
    </script>
</body>
</html>
